# Group-064 Chess Program Design Document

## Specification
#### Player register
The user can register a player user by inputting a username and a password in the register page that can be accessed through the initial menu of the program webpage. If the username is already used in the user information database, a message is outputted informing the user that the username is already in use. If the username is not already in the user information database, the user information is stored in the database and a message is outputted informing the user that they have successfully registered an account.
#### Player password reset
The user can request to change the password of their player user through the login page. To do this, the user inputs their username, their desired new password, and their email. Once they submit this information, a message is displayed telling them to wait until the administrator contacts them (through their email). This information (the username, the desired new password, and the email) is viewable by the master user in their reset password page, so that they can reset these passwords then contact the emails listed to inform them that their password is reset.
#### Player login
The user can log in as a player by inputting their username and password in the player login page that can be accessed through the initial menu of the program webpage. If the username is not in the database or if the password does not match the username's associated password, a message is outputted that says that their username or password is incorrect, and to try again. If the username is in the database and the password matches the username's associated password, then the user is redirected to the "Welcome to board" page of the program.
#### Playing the game
The button to start the game can be found in the "Welcome to board" page of the program. The program also displays the username of the currently logged in user, and their Elo rating. If the user chooses to hit the play button, they are redirected to a page that lists the currently online players. On this page, they can input one of the online players' usernames and which colour they would like to play as. The way to have other online players is to open another webpage of the application and log in as another user. This will cause both of the logged in users to show up on the online players list. If the user inputs a username of an online player and a valid colour to play as, the match begins and a GUI of a chess board opens. The two users use this chess board to play chess. They input their moves by dragging and dropping the pieces on the board. The board outputs the outcomes of the move by updating the board to reflect the moves made. If a piece is dragged to make an invalid move, such as moving a piece to a place it cannot legally move to or moving a piece of a colour whose turn it is not, said piece will reappear back in its original spot and it will still be the players whose turn it was' turn. There are also undo and redo buttons that the user can interact with by clicking on them, which will cause a move to be undone or redone, respectively. The board outputs the result of the undo/redo by returning the board to the state it had been previously. If the board is in a checkmate state, the program displays a message informing the users that there is a checkmate and that the match is over. The program then recalculates both users' Elo ratings based on the result of the match (which user won and which user lost). This updated Elo rating can be seen in the "Welcome to board" page of the program.
#### Master user login
The user can log in as a master user by inputting a username and password in the master user login page that can be accessed through the initial menu of the program webpage. There is only one set of username and password for the master user. The username is "masterusername" and the password is "masteruserpassword". It is not possible to register new master users to prevent access of the database by people who do not know the master user login information. If the inputted username and password are correct, the user is redirected to the master user console page. 
#### Manipulate user login database
Master users are able to manipulate the database that contains the login information of the player users. The manipulations they can make are resetting passwords, and deleting users, with each of these functions having their own pages. The pages to perform these functions are accessible through the master user console page. The master user console page also displays the number of users that are currently online. 
The reset password page features a table at the top that displays password reset requests from users. This table includes the usernames of these users, their desired new password, and their emails. The master user can input a username and a password to update the player with that username's password to the inputted password. If the username is not in the database, a message is outputted that says that the username does not exist in the system. If the username is in the database, then the player with that username's password is changed to the inputted password and a message is outputted informing the master user that the password has been successfully changed. 
In the delete user page, the master user can input the username and password of a player they wish to delete. If the inputted username is not in the database, then a message is outputted informing the master user that the username does not exist in the system. If the inputted password does not match the username's associated password, a message is outputted that says that the deletion was a failure. If the username is in the database and the password matches the username's associated password, then the user is deleted from the database and a message is outputted informing the master user that the player has been successfully deleted.

## Major Design Changes and Explanation
One major change implemented is the inclusion of two different types of users. Originally, the program only had one type of user, a user that was able to use the program to play chess. We have now updated this so there are two types of users: a player and a master user. The player is the same as the generic user the program had prior to the design change, a user that is able to play chess. The master user is able to view and edit the login information of all the players stored in the database and is unable to play chess. 

Another major change was our transition to SpringBoot to improve the user experience. We used to rely on command lines, ``RegisterGui``, and ``LoginGui`` to get data from users and present them with options and feedback. We chose to switch to Spring Boot because as we developed more services in Phase 2 such as resetting password and deleting players, using GUIs as a bridge to communicate with users became difficult: first there would be too many GUIs to pop up for different service, second it was likely to slow down and even crash the program, and third the communication with different GUIs is hard. For example, when a player sends a request to reset password from a GUI, how can another GUI pop up for the master user reflecting that request? It is still possible to implement this idea using GUI but it is complicated. However, Web can resolve this problem because it serves as a container with built-in requests, responses, and models to help connect different parts of the program. For example, the request and parameters for resetting passwords from players can be mapped by and flowed to a method which can respond with and pass on those parameters to corresponding web pages. As a result, it provides a smooth way to connect our program and enhances user experience. Furthermore, our Spring Boot project structure can separate the work of front-end from back-end very well to decrease code dependency. 

## How Project Adheres to Clean Architecture
Generally, our entire project is interacting with the UI which is web. Within the project, we design controllers, databases, use cases, and entities, as shown below:

![Clean architecture model of program](https://i.pinimg.com/564x/2e/ca/64/2eca642f093c1645430bf2c288a367f7.jpg)

The **innermost layer** is the place for entities, including ``Piece``, ``King``, ``Queen``, ``Rook``, etc along with ``Game``, ``Board``, and ``Users``. The project is well segmented into clearly defined layers, the innermost of which governs the basics of the pieces in the abstract ``Piece`` class and its subclasses. The next layer up is the ``Board`` which uses the properties of individual pieces and the positions of many of them to handle moves and move legality.

The **outermost layers** are players/users of our project and databases which can store players’ information on a persistent basis. 

**Controllers lie in one layer inside** to handle different requests sent from players such as register, login, reset passwords, and start the game, or those from the master user (administrator of the database) to reset passwords and delete inactive players. In the same layer, there are also **presenters and repositories**. Presenters are html files to present the project to web-pages, collect data entered by players, and send it to the controllers. Repositories are classes operating on databases like Sql and MongoDB. 

**In the middle**, we have use case classes such as ``UserService`` and ``GameService`` to receive jobs assigned from controllers and complete the job by running business logic and collaborating with databases/repositories. There is also a ``GameService`` class that is responsible for prompting players with the ``GameGUI``.

Under this design, presenters and repositories are working with players and the database, controllers play the role of facades to delegate work to their corresponding user case classes. The use case classes will interact with database/repositories like accessing and updating players’ information or starting off a chess game for players. Entities can work on their own without any dependency on use cases or controller classes. As a result, the outer layer will depend on inner layer classes but inner classes do not depend on outer classes.

Below are our two examples to show this:

![Layer interactions](https://i.pinimg.com/564x/81/1d/0d/811d0d0771e90fd08faebcc0534cf573.jpg)

## How Project is Consistent With SOLID Principles
### Single Responsibility Principle
We segment the project in such a way that piece classes store and handle their own information while the board class handles the overall position of the pieces in relation to each other and using that information, verifies the legality of their moves. The Game class above Board handles the overall game state and menus while providing a single point of contact between Board which stores the information, and GameGui which displays that information. [Controllers](https://github.com/CSC207-UofT/course-project-group-064/commit/6d37f6f9bbb661c164f0cbf049c148c0172065c8#diff-25a6634263c1b1f6fc4697a04e2b9904ea4b042a89af59dc93ec1f5d44848a26) are split into 3 controllers with each handling individual tasks.
### Open-Closed Principle
The construction of the ``checkMoveLegal`` and ``getLegalMoves`` methods is such that they are segmented into numerous helper methods that check move legality for specific piece types, which means that features including different rule sets or even entirely new pieces could be added without modifying the existing legality checks. 

The [Database design](https://github.com/CSC207-UofT/course-project-group-064/commit/3ec69d34d61a0bc87eb9d4bc19bb910253410d0e#diff-25a6634263c1b1f6fc4697a04e2b9904ea4b042a89af59dc93ec1f5d44848a26) complies with this principle by designing an interface ``Database`` and implementing classes like ``UserInfoDB`` and ``UserInfoDB2``. This makes it open for future clients of the code to have their different implementation of databases and closed for modification for the code using a database object. 
### Liskov Substitution Principle
A move from any piece type can be passed into the ``checkMoveLegal`` function, from there it is filtered into more specific checks for its type, all of which is done automatically. Each piece type is accounted for. 

We compose a ``Database`` object in ``UserServiceImpl1`` class and treat it no matter its type (``UserInfoDB`` or ``UserInfoDB2`` or others). We are using ``UserInfoDB2`` by annotating ``UserInfoDB2`` as ``@Repository`` at the moment. However, it is easy for us to transit to ``UserInfoDB`` later on whenever necessary, and people who are working on ``UserService`` layer do not need to worry about any difference between ``UserInfoDB`` and ``UserInfoDB2``. This can be seen [here](https://github.com/CSC207-UofT/course-project-group-064/blob/b9af9f725c4dc5e42247898388461deef4f1165d/src/main/java/com/playchessgame/chessgame/UserService/impl/UserServiceImpl1.java#L13-L20).

### Interface Segregation
Splitting Pieces into specific subclasses rather than having a String type instance variable allows a piece like a bishop or a knight to ignore what would be extraneous, unnecessary information like the notMoved variable used for Kings, Rooks, and Pawns.  

### Dependency Inversion
The ``Game`` and ``GameGui`` classes get information directly from ``Board`` which in turn processes information from the various ``Piece`` classes. ``Game`` does not import ``Piece`` or any of its subclasses. Similarly, the ``User`` and database-related classes have no reason to interact with ``Pieces`` or the ``Board``, they get information about game results directly from the ``Game`` and ``GameGui`` classes.

Our [``UserService``](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-28306619734be4437310bcd1372818fe31d29f697d3c94c789b65af921de42aa) class needs to call methods in repositories which lay outside use case layers. So to make that happen without violating principle, our ``UserService`` class composes the ``Database`` interface rather than concrete repository objects to avoid inverse dependency from inside to outside. Also, our repositories implement this ``Database interface``. This design is consistent with the dependency inversion principle. 

## [Packaging Strategies](https://github.com/CSC207-UofT/course-project-group-064/commit/98423f5f50301556a119c01b419c0ff60f69fe98#diff-25a6634263c1b1f6fc4697a04e2b9904ea4b042a89af59dc93ec1f5d44848a26)
We have 3 basic folders: *java* for java codes, *resources* for our configuration and html files, and *test* for tests for our codes.

![Basic folder packages](https://i.pinimg.com/564x/60/2c/fe/602cfe3ef928f10b69509771c31b183c.jpg)

In the Java folder, our codes are put in the com.playchessgame folder in which codes are further organized by “layers” as: entities, user case, controller, database, exceptions, and config.

In the ``Entity`` package, we have ``User`` classes, ``Board`` class, ``Game`` class, ``Piece`` class, and other classes extending ``Piece`` class like ``King``, ``Queen``, ``Rook`` and etc. Those classes are in the most-inner layer and will not rely on any classes in other packages.

![Entity package](https://i.pinimg.com/564x/b8/85/92/b885929f04fc71d57e110f740748a87e.jpg)

In Controllers package, we have ``PageController``, ``UserController``, and ``MasterUserController`` classes. We designed 3 controllers because we figured out there are generally 3 kinds of businesses our project provides: 
1. Service for players ranging from register, login, to play the game; 
2. Service for master users including monitoring the system and managing the database.
3. Service for directing pages for users.

![Controller package](https://i.pinimg.com/564x/10/66/47/106647f482ab117594b42940591da4b0.jpg)

In the [use case layer](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714), we have ``GameService`` and ``UserService`` classes. They are receiving delegated works from controllers and completing them with business logic and collaboration with databases. Specifically, the [GameService](https://github.com/CSC207-UofT/course-project-group-064/commit/e2c5fcdd6fc58f3a05eeb1d7a90f20f16158c623#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) is the ``GameGui`` which is responsible for providing a visualized game board for players on a living basis. The [UserService](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) has ``UserService`` and ``MasterUserService``: ``UserService`` provides service for players to register, log in, and start off the game; [``MasterUserService``](https://github.com/CSC207-UofT/course-project-group-064/commit/c363077b7455f5fb0e8a42f5b3d849f8bcbc4ea7#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) provides service for master users to monitor the system activities including the current number of online players and to manage the database such as reset passwords for players and delete inactive players from databases.

![Use case package](https://i.pinimg.com/564x/1e/3e/ec/1e3eecce29eaba25a07a58136585559f.jpg)

In the Database package, we design an interface ``Database`` that provides services including connecting with the database, creating a new database and adding, reading, updating, and deleting players to and from databases. Based on the Open-Closed Principle, we plan to offer flexibility in how the database is implemented. So we have 2 database implementations, one is for MySql and the other one is for MongoDB, allowing future clients to choose if they want to reply on the local database (MySql) or online database(MongoDB) or even to design their preferred database. This design also follows the dependency injection principle by letting use case classes compose ``Database`` interface which is implemented by ``UserInfoDB`` and ``UserInfoDB2``.

![Database package](https://i.pinimg.com/originals/25/e3/ff/25e3ffe5ce331c35b8380a2b0a112001.jpg)

In the [Exceptions](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) package, we defined ``UserAlreadyExistsException`` and ``UserAlreadyExistsException`` exceptions which are thrown from database and handled in use cases. Those exceptions provide a great communication way between Database layer and Service layer.

![Exceptions package](https://i.pinimg.com/564x/59/4a/26/594a2672367b81c528493f510e7b839c.jpg)

In [Config](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) and [ContextService](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) packages, there are configuration files on which Spring Boot relies on as it is booting. Those configuration files help initialize objects like MongoDB connection and ``MyListerner`` which are needed in the life cycle of our program.

![Config and ContextService packages](https://i.pinimg.com/564x/91/91/2a/91912a892045f99990ee542dab2effa4.jpg)

##Design Patterns
Chess pieces are an example of the template method design pattern because ``Piece`` defines the skeleton and then defers steps to subclasses like ``Pawn``, ``Rook``, etc. It also establishes placeholders for the subclasses to implement. The different user classes also demonstrate the template method design pattern, with a framework ``User`` class and the ``PlayerUser`` and ``MasterUser`` classes extending the framework.

[``UserController``](https://github.com/CSC207-UofT/course-project-group-064/commit/39a657fb01469bb0cefae8eeae973807f646f658#diff-a387dff114120f1008c8acbe0a8da599e1e9d5a962671d0d82712ae19ac2f648) is a facade. The ``UserController`` class is a facade of the register and login part of our program by collecting information from players and presenting results to them. The class does not contain many implementation details and instead, it delegates register and login work to other classes ([``UserService``](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714)) and maps [presenting pages](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) containing register and login results to html files. So if one simply looks at the ``UserController`` class itself, one will be able to understand what kind of services our program provides for players, but one will not know in which way they are provided because it is encapsulated in the delegated classes and mapped files. . 

The Undo/Redo function was directly implemented using the Memento design pattern. [``Caretaker``](https://github.com/CSC207-UofT/course-project-group-064/blob/main/src/main/java/com/playchessgame/chessgame/Entities/Caretaker.java), [``Memento``](https://github.com/CSC207-UofT/course-project-group-064/blob/main/src/main/java/com/playchessgame/chessgame/Entities/Memento.java), and [``Originator``](https://github.com/CSC207-UofT/course-project-group-064/blob/main/src/main/java/com/playchessgame/chessgame/Entities/Originator.java) classes are packaged inside [Entities](https://github.com/CSC207-UofT/course-project-group-064/tree/main/src/main/java/com/playchessgame/chessgame/Entities) and interact together with ``GameGui`` and ``Board`` to display 2 interactable buttons that [undo](https://github.com/CSC207-UofT/course-project-group-064/blob/069b05c54c7de7c92a7a266d7081a49139dd68da/src/main/java/com/playchessgame/chessgame/GameService/GameGui.java#L197) and [redo](https://github.com/CSC207-UofT/course-project-group-064/blob/069b05c54c7de7c92a7a266d7081a49139dd68da/src/main/java/com/playchessgame/chessgame/GameService/GameGui.java#L225) each move respectively. The ``Originator`` class gets and sets mementos, the ``Memento`` class creates and returns specific mementos, and the ``Caretaker`` class keeps 2 stacks of all the stored mementos ([one for undo](https://github.com/CSC207-UofT/course-project-group-064/blob/069b05c54c7de7c92a7a266d7081a49139dd68da/src/main/java/com/playchessgame/chessgame/Entities/Caretaker.java#L8), [one for redo](https://github.com/CSC207-UofT/course-project-group-064/blob/069b05c54c7de7c92a7a266d7081a49139dd68da/src/main/java/com/playchessgame/chessgame/Entities/Caretaker.java#L9)).

``GameGui`` is an example of a listener design pattern. Players need to be notified by some updates in ``GameGui`` so the ``GameGui`` composes them and calls their ``updateElo()`` method. In this way, players (listeners) will be notified by the change in ``GameGui`` (events). 

[``MyListener``](https://github.com/CSC207-UofT/course-project-group-064/commit/39a657fb01469bb0cefae8eeae973807f646f658#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) class is another example of a listener design pattern. When the program boots, an ``HttpSessionListener`` object will be created and registered into Spring Boot LOC container and the ``HttpSessionListener`` object is responsible for monitoring and listening to web sessions activities. Its ``sessionCreated()`` method will be called whenever a session is created and ``sessionDestroyed()`` method will be called whenever a session is destroyed. Those callings will result in updates in parameters like online the number of online players.

## Refactoring
We primarily used a discord server created for this project to go over issues and refactor our code. 

![Discord messages about refactoring](https://i.pinimg.com/564x/2a/05/a2/2a05a2edfd8f928a235114f01a811fef.jpg)

The above exchange comes from Victor and Nathaniel’s time reworking elements of the ``inCheck`` method to improve readability and address minor code smells. Having the message record of this conversation also helped fix a similar issue later in phase 2 in which pawns were only capturing diagonally right rather than both left and right due to a similar programming error.

![More Discord messages about refactoring](https://i.pinimg.com/564x/be/a7/7b/bea77b4257e3037a8b5f4a9759735337.jpg)

Similar conversations accompanied the integration of the disparate elements of our project such as the GUI and rules as shown above. This conversation, in particular, allowed us to remove a relic of the command-line interface version of our project since ``makePlayerMove()`` had previously taken a string move input as a parameter however it was already using helper methods to translate that parameter to integers so this change simply removed that extra step. Conversations like these occurred both in text and voice chats throughout the course of the project.

Most of the methods in ``UserInfoDB2`` reply on ``MongoCollection``. To avoid duplicate codes, we extract this step out to a private helper [getCollection()](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-b59ec19f08323f3a6ba90163dfc0a5760ed103d7e7ad741193cfebad40219714) which is called by other methods in the class. Refactoring was also used in extracting helper methods as such in the [``inCheckHelper``](https://github.com/CSC207-UofT/course-project-group-064/blob/069b05c54c7de7c92a7a266d7081a49139dd68da/src/main/java/com/playchessgame/chessgame/Entities/Board.java#L267) methods, [``castleHelper``](https://github.com/CSC207-UofT/course-project-group-064/blob/069b05c54c7de7c92a7a266d7081a49139dd68da/src/main/java/com/playchessgame/chessgame/Entities/Board.java#L515), and [``copyHelper``](https://github.com/CSC207-UofT/course-project-group-064/blob/069b05c54c7de7c92a7a266d7081a49139dd68da/src/main/java/com/playchessgame/chessgame/Entities/Board.java#L580) method in ``Board.java``. This can be seen [here](https://github.com/CSC207-UofT/course-project-group-064/blob/7daed172a08aa832749922e50a47280b78a439d0/src/main/java/com/playchessgame/chessgame/Database/impl/UserInfoDB2.java#L29-L33).

## Accessibility Design (Flexibility in use)
``GameGui`` provides both black and white pieces on the board,  so players can easily remember their roles, spot their pieces, and consider which piece they can move in the next step.

![Chessboard GUI](https://i.pinimg.com/564x/42/43/41/42434123b0c731d781f0ce6b360a8381.jpg)

Additionally, the web page design provides [placeholders](https://github.com/CSC207-UofT/course-project-group-064/commit/08fe4c7f61515c4a74f1614faa28b826056abb3f#diff-28306619734be4437310bcd1372818fe31d29f697d3c94c789b65af921de42aa) in input boxes which show little friendly instructions for users what information they need to type. Below is an example:

![Login GUI](https://i.pinimg.com/564x/3e/0c/85/3e0c8597d14e275044d102b7c086c8ca.jpg)

## Progress Report
Omar: Worked collaboratively with Snow to finish the ``UserInfoDB2`` class and implementing the two user types. Specifically, finishing ``UserInfoDB2`` involved implementing the methods needed for the master user functions, [``deleteUserInfo``](https://github.com/CSC207-UofT/course-project-group-064/blob/7daed172a08aa832749922e50a47280b78a439d0/src/main/java/com/playchessgame/chessgame/Database/impl/UserInfoDB2.java#L82-L98), [``updateUserPassword``](https://github.com/CSC207-UofT/course-project-group-064/blob/7daed172a08aa832749922e50a47280b78a439d0/src/main/java/com/playchessgame/chessgame/Database/impl/UserInfoDB2.java#L128-L143), and [``updateUserElo``](https://github.com/CSC207-UofT/course-project-group-064/blob/7daed172a08aa832749922e50a47280b78a439d0/src/main/java/com/playchessgame/chessgame/Database/impl/UserInfoDB2.java#L153-L167). Also added javadoc to the previously implemented database and user classes, and the newly implemented ones. After the ``UserInfoDB2`` class was fully implemented, wrote the ``DatabaseTest`` class and all the tests within it to ensure everything had been implemented properly. After the group had completed a design document on a shared Google Document, reformatted everything for the Github Markdown.

Nathaniel: Worked on finishing up rules implementation. We realized we needed a method to get a list of all legal moves for a given player in order to calculate checkmate and stalemate since the easiest way to check for these is to see that the set of legal moves for a side is empty. That was my first priority. It involved putting together all of our individual piece move-getter methods, iterating over a list of all pieces of a given color, and working on determining a way to associate the origin point with the list of all possible destinations. Once I did that, checkmate followed easily by simply calling Victors ``inCheck`` method and looking to see that the list returned by ``getLegalMoves`` was empty. After that, I finished with minor rules like pawn promotion and focused on integrating the rules code with David’s GUI. I also wrote the Elo calculation methods using the official formula Arpad Elo developed in the sixties with basic code in the ``PlayerUse``r class which inflates a player’s k-factor before they’ve finished their first ten games, allowing the rating more sensitivity in a smaller sample of games.     

David: Worked on GUI implementation. Currently, GUI can interact with click and drag or command line input, but the backend only parses the command line. Knows how to fix the click and drag issue and it’s just a matter of time. Having slight difficulty with many possible design and implementation decisions, but nothing unmanageable. There are a lot of online resources for Java Swing, but each recommends their own unique implementations, etc and it can be challenging to sort through the many options. Next immediate steps are fixing the click and drag issue and general cleanup of the code. After that I will work on further integration with the login and database, and try to make the interface more visually pleasing (e.g. adding valid move indicators). 

Snow: Worked on building the [Spring Boot framework](https://github.com/CSC207-UofT/course-project-group-064/tree/springboot) for our project, [creating and designing web pages](https://github.com/CSC207-UofT/course-project-group-064/commit/defdfdd91b6962cb8c19b5e74487be7cc3330e03#diff-ea2c6d949817cf6f06f5a11be810df22afa59b35584da1df45113f81e15e23ab) using Thymeleaf, [considering ways of mapping various requests sent from users](https://github.com/CSC207-UofT/course-project-group-064/commit/b722a489e9cf75d32f0454c8f6ba31e31c66468a#diff-ea2c6d949817cf6f06f5a11be810df22afa59b35584da1df45113f81e15e23ab), and running tests for Spring Boot functionalities. Also worked on [implementing UserInfoDB2 using MongoDB](https://github.com/CSC207-UofT/course-project-group-064/commits/packaging/src/com.PlayChessProject/Database), [setting up controllers and use cases](https://github.com/CSC207-UofT/course-project-group-064/commits/packaging/src/com.PlayChessProject), and organizing our codes by layers. Collaborated with Omar on database interface design, implementation, and testing. During the project, Learned from scratch on how to build a Spring Boot project and developed logic in how to connect our classes cross layers in a reasonable way when working on controllers and use cases design. For example, it is applicable to connect classes by: ``UserController`` <-> ``UserService`` <-> ``GameGui`` <-> ``Database`` <-> ``User``. Also learned properties of a web project when building Spring Boot framework like HttpSession, HttpSessionListener, Configuration, Bean, and steps by which a web project can be configured, initialized, and kicked off.

Victor: In this phase of the project, I helped Nat finish up the rules implementation. I [created the castle method](https://github.com/CSC207-UofT/course-project-group-064/commit/dcb6fcbbb6ef291fedba089be79d40a8dd487844), which involves two helper methods to make work. One was to check each requirement for castling and return the possible castle moves, and the other was to directly move the Rook, when a valid castle was made. I ran into multiple bugs coding this, and Nat helped me in identifying weaknesses in the code. I decided we could add a different design pattern to our project, and that most chess programs have the function of undo/redo moves, thus I used the Memento Design pattern to include the function into our game. This was very confusing since I did not interact with David’s code before trying to implement this, therefore I had no idea how Spring and the GUI class worked. Fortunately I was able to figure it out with good communication with David, and I implemented it using an index-based concept in which it pulls up the specific memento if the index was greater than a specific value. However, this approach didn’t work since if we made moves 1, 2, 3, 4, undoed twice to move 2, and made another move (5), it would return 3 on the next redo instead of 5 (should be 1, 2, 5). This forced me to refactor the index-approach into a stack-based approach, which resolved the problem and allowed [undo/redo to work properly](https://github.com/CSC207-UofT/course-project-group-064/commit/5a57d407cb9274fba3c01ee11adef328bbad0a30#diff-32d49112ca8c65ad226a8128c3e567e8f354468efde24c10ed9dcb7980e2387c). I also added a [copy(Board)](https://github.com/CSC207-UofT/course-project-group-064/blob/5a57d407cb9274fba3c01ee11adef328bbad0a30/src/main/Board.java#L499) method to Board.java which creates a deep copy of the current board, since I ran into multiple aliasing issues when using the Memento pattern. The ``copyHelper`` was also extracted out of the method because it was creating a long method. Also helped David fix [a bug](https://github.com/CSC207-UofT/course-project-group-064/commit/c02d357bcedf78442d3f0921e43f6d8ed1420302) in the GUI code in which the program was freezing the pieces when two buttons were pressed while dragging.
